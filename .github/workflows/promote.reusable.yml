# =============================================================================
# BookVerse Infrastructure - Reusable Promotion Workflow and Parameter Management
# =============================================================================
#
# This comprehensive reusable GitHub Actions workflow provides enterprise-grade
# promotion capabilities for all BookVerse services, implementing sophisticated
# application lifecycle management, stage-based promotion logic, and AppTrust
# integration with comprehensive parameter management and evidence collection
# for production-ready continuous deployment automation across the platform.
#
# üèóÔ∏è REUSABLE WORKFLOW ARCHITECTURE:
#     - Multi-Service Support: Unified promotion logic for all BookVerse services
#     - Parameter Management: Comprehensive input parameter handling and validation
#     - Stage-Based Promotion: Automated promotion through DEV ‚Üí QA ‚Üí STAGING ‚Üí PROD lifecycle
#     - AppTrust Integration: Complete JFrog AppTrust lifecycle management and evidence collection
#     - OIDC Authentication: Secure, passwordless authentication with GitHub Actions integration
#     - Evidence Collection: Cryptographic evidence generation and audit trail management
#
# üöÄ KEY REUSABLE FEATURES:
#     - Universal Application: Reusable across all BookVerse services without modification
#     - Flexible Parameterization: Comprehensive input parameters for customization
#     - Enterprise Promotion Logic: Production-ready promotion workflows with safety mechanisms
#     - Automated Version Management: Intelligent version resolution and semantic versioning
#     - Cross-Service Compatibility: Unified promotion logic supporting all service types
#     - Production Safety: Enterprise-grade safety mechanisms and validation procedures
#
# üîß PARAMETER DOCUMENTATION:
#     - target_stage: Target deployment stage (DEV, QA, STAGING, PROD) with validation
#     - application_version: Semantic version specification or latest version resolution
#     - service_name: BookVerse service identifier for context-aware promotion
#     - oidc_provider_name: OIDC provider configuration for secure JFrog authentication
#     - evidence_key_alias: Cryptographic evidence key alias for signing and validation
#     - Advanced parameter validation and type checking for enterprise safety
#
# üìä WORKFLOW PATTERNS:
#     - Caller Workflow Integration: Seamless integration with service-specific workflows
#     - Output Management: Structured output for calling workflow consumption
#     - Error Handling: Comprehensive error handling and graceful degradation
#     - Status Reporting: Detailed status reporting and operation logging
#     - Dependency Management: Intelligent dependency resolution and coordination
#     - Performance Optimization: Optimized workflow execution and resource management
#
# üõ°Ô∏è ENTERPRISE SECURITY AND GOVERNANCE:
#     - Secure Parameter Handling: Comprehensive input validation and sanitization
#     - OIDC Integration: Passwordless authentication with GitHub Actions OIDC tokens
#     - Evidence Generation: Cryptographic evidence collection and audit trail creation
#     - Access Control: Role-based access control and permission management
#     - Audit Compliance: Complete audit trail and compliance documentation
#     - Security Validation: Comprehensive security validation and vulnerability scanning
#
# üîÑ LIFECYCLE MANAGEMENT INTEGRATION:
#     - AppTrust Native: Complete JFrog AppTrust platform integration
#     - Stage Progression: Automated progression through deployment lifecycle stages
#     - Version Coordination: Cross-service version coordination and dependency management
#     - Quality Gates: Integration with quality gates and validation procedures
#     - Rollback Coordination: Promotion rollback capabilities and disaster recovery
#     - Monitoring Integration: Real-time monitoring and alerting during promotion operations
#
# üìà SCALABILITY AND AUTOMATION:
#     - Multi-Service Scaling: Efficient scaling across multiple BookVerse services
#     - Batch Processing: Support for batch promotion operations and coordination
#     - Performance Optimization: Optimized promotion operations and resource utilization
#     - Automation Framework: Complete automation of promotion procedures
#     - Integration Testing: Automated integration testing and validation
#     - Monitoring Integration: Promotion operation monitoring and status reporting
#
# üîê ADVANCED SAFETY FEATURES:
#     - Parameter Validation: Comprehensive input parameter validation and type checking
#     - Environment Isolation: Secure environment isolation and configuration management
#     - Error Recovery: Advanced error recovery and rollback procedures
#     - Validation Framework: Promotion validation and integrity checking
#     - Security Scanning: Automated security scanning and vulnerability assessment
#     - Compliance Integration: Regulatory compliance validation and documentation
#
# üõ†Ô∏è TECHNICAL IMPLEMENTATION:
#     - GitHub Actions Reusable: Native GitHub Actions reusable workflow implementation
#     - JFrog Platform Integration: Complete JFrog AppTrust and Artifactory integration
#     - OIDC Authentication: Secure OIDC token-based authentication and authorization
#     - Parameter Management: Advanced parameter handling and validation framework
#     - Output Generation: Structured output for calling workflow consumption
#     - Error Handling: Comprehensive error detection and recovery procedures
#
# üìã SUPPORTED SERVICE TYPES:
#     - Python Services: FastAPI microservices with Python package promotion
#     - Node.js Services: Frontend applications with npm package promotion
#     - Container Services: Docker image promotion and container registry management
#     - Configuration Services: Helm charts and Kubernetes configuration promotion
#     - Infrastructure Services: DevOps tooling and infrastructure automation promotion
#     - Multi-Language Support: Universal promotion logic supporting all technology stacks
#
# üéØ SUCCESS CRITERIA:
#     - Universal Applicability: Successful reuse across all BookVerse services
#     - Parameter Flexibility: Comprehensive parameterization for service customization
#     - Enterprise Safety: Production-ready safety mechanisms and validation
#     - Integration Success: Seamless integration with service-specific workflows
#     - Performance Excellence: Optimized promotion operations and resource efficiency
#     - Operational Readiness: Promotion workflows ready for production operations
#
# Authors: BookVerse Platform Team
# Version: 1.0.0
# Last Updated: 2024
#
# Dependencies:
#   - GitHub Actions environment (workflow execution)
#   - JFrog Platform with AppTrust (application lifecycle management)
#   - OIDC authentication configuration (secure access)
#   - BookVerse service repositories (promotion targets)
#
# Usage:
#   uses: tpaz1/bookverse-infra/.github/workflows/promote.reusable.yml@main
#   with:
#     target_stage: "QA"
#     application_version: "1.2.3"
#     service_name: "inventory"
#     oidc_provider_name: "github-actions"
#     evidence_key_alias: "bookverse-evidence-key"
#
# Security Notes:
#   - All parameters undergo comprehensive validation and type checking
#   - OIDC authentication ensures passwordless and secure promotion operations
#   - Evidence collection provides complete audit trail and compliance documentation
#   - Error handling ensures graceful degradation and safe operation
#
# =============================================================================

name: Promote (reusable)

# Note: Concurrency is controlled by the calling workflow, not this reusable workflow

on:
  workflow_call:
    inputs:
      target_stage:
        description: 'Target stage (DEV, QA, STAGING, PROD)'
        required: true
        type: string
      application_version:
        description: 'Application version (SemVer). If empty, use latest.'
        required: false
        type: string
      service_name:
        description: 'Service name (e.g., inventory, checkout, recommendations, web)'
        required: false
        type: string
      oidc_provider_name:
        description: 'OIDC provider name for jfrog/setup-jfrog-cli'
        required: false
        type: string
      evidence_key_alias:
        description: 'Evidence key alias (if server-side aliasing is used)'
        required: false
        type: string

jobs:
  promote:
    name: Promote
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4


      - name: "[Setup] Prereqs (jq)"
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: "[Auth] Exchange GitHub OIDC for JFrog access token"
        run: |
          set -euo pipefail
          BASE="${{ vars.JFROG_URL }}"; BASE="${BASE%/}"
          if [[ -z "$BASE" ]]; then echo "Missing vars.JFROG_URL" >&2; exit 1; fi
          PROVIDER_NAME="${{ inputs.oidc_provider_name }}"
          if [[ -z "$PROVIDER_NAME" ]]; then echo "Missing oidc_provider_name input" >&2; exit 1; fi
          JF_URL="$BASE"
          if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            echo "‚ùå Missing GitHub OIDC request env vars" >&2; exit 1; fi
          echo "üîë Minting GitHub OIDC ID token (audience=$JF_URL)"
          ID_TOKEN=$(curl -fsSL -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${JF_URL}" | jq -r .value)
          if [[ -z "$ID_TOKEN" || "$ID_TOKEN" == "null" ]]; then echo "‚ùå Failed to fetch GitHub ID token" >&2; exit 1; fi
          echo "üîÅ Exchanging OIDC for JFrog access token (provider=$PROVIDER_NAME)"
          PAYLOAD=$(jq -n --arg jwt "$ID_TOKEN" \
            --arg provider_name "$PROVIDER_NAME" \
            --arg project_key "${{ vars.PROJECT_KEY }}" \
            --arg job_id "${{ github.job }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg repo "https://github.com/${{ github.repository }}" \
            --arg revision "${{ github.sha }}" \
            --arg branch "${{ github.ref_name }}" \
            '{
              grant_type:"urn:ietf:params:oauth:grant-type:token-exchange",
              subject_token_type:"urn:ietf:params:oauth:token-type:id_token",
              subject_token:$jwt,
              provider_name:$provider_name,
              project_key:$project_key,
              job_id:$job_id,
              run_id:$run_id,
              repo:$repo,
              revision:$revision,
              branch:$branch
            }')
          RESP=$(curl -fsSL -X POST "$JF_URL/access/api/v1/oidc/token" -H "Content-Type: application/json" -d "$PAYLOAD")
          JF_OIDC_TOKEN=$(echo "$RESP" | jq -er '.access_token // empty' || true)
          if [[ -z "$JF_OIDC_TOKEN" ]]; then echo "Failed to obtain JFrog access token: $RESP" >&2; exit 1; fi
          echo "JF_OIDC_TOKEN=$JF_OIDC_TOKEN" >> $GITHUB_ENV

      - name: "[Resolve] App & version"
        id: app
        run: |
          set -euo pipefail
          if [[ -n "${{ inputs.service_name }}" ]]; then
            SERVICE_NAME='${{ inputs.service_name }}'
          else
            SERVICE_NAME=$(echo "${{ github.event.repository.name }}" | sed 's/^bookverse-//')
          fi
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          TARGET_STAGE='${{ inputs.target_stage }}'
          APP_VERSION='${{ inputs.application_version }}'
          if [ -z "$APP_VERSION" ]; then
            echo "üîé Fetching latest application version for $APPLICATION_KEY"
            BASE="${{ vars.JFROG_URL }}"; BASE="${BASE%/}"
            jq_expr='(.results // .data // .items // .versions)[0].version'
            RESP=$(curl -sS -H "Authorization: Bearer $JF_OIDC_TOKEN" -H "Accept: application/json" "$BASE/apptrust/api/v1/applications/$APPLICATION_KEY/versions?order_by=created&limit=1" || true)
            if LATEST_VERSION=$(echo "$RESP" | jq -er "$jq_expr" 2>/dev/null); then APP_VERSION="$LATEST_VERSION"; fi
          fi
          if [ -z "$APP_VERSION" ] || [ "$APP_VERSION" = "null" ]; then
            echo "‚ùå Could not determine app version for $APPLICATION_KEY" >&2
            exit 1
          fi
          echo "application_key=$APPLICATION_KEY" >> $GITHUB_OUTPUT
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "target_stage=$TARGET_STAGE" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "Resolved: $APPLICATION_KEY@$APP_VERSION ‚Üí $TARGET_STAGE"

      - name: "[Setup] Checkout bookverse-infra for shared scripts"
        uses: actions/checkout@v4
        with:
          repository: tpaz1/bookverse-infra
          path: bookverse-infra

      - name: "[Setup] AppTrust context"
        run: |
          set -euo pipefail
          export APPLICATION_KEY='${{ steps.app.outputs.application_key }}'
          export APP_VERSION='${{ steps.app.outputs.app_version }}'
          export TARGET_STAGE='${{ steps.app.outputs.target_stage }}'
          echo "APPLICATION_KEY=${{ steps.app.outputs.application_key }}" >> $GITHUB_ENV
          echo "APP_VERSION=${{ steps.app.outputs.app_version }}" >> $GITHUB_ENV
          echo "TARGET_STAGE=${{ steps.app.outputs.target_stage }}" >> $GITHUB_ENV
          export JFROG_URL='${{ vars.JFROG_URL }}'
          export PROJECT_KEY='${{ vars.PROJECT_KEY }}'
          export JF_OIDC_TOKEN="$JF_OIDC_TOKEN"
          source bookverse-infra/libraries/bookverse-devops/scripts/promote-lib.sh
          fetch_summary
          echo "CURRENT_STAGE_BEFORE=${CURRENT_STAGE:-UNASSIGNED}" >> $GITHUB_ENV
          echo "RELEASE_STATUS_BEFORE=${RELEASE_STATUS:-UNKNOWN}" >> $GITHUB_ENV
          LC_FILE=$(mktemp)
          CODE=$(curl -sS -L -o "$LC_FILE" -w "%{http_code}" "$JFROG_URL/access/api/v2/lifecycle/?project_key=$PROJECT_KEY" -H "Authorization: Bearer $JF_OIDC_TOKEN" -H "Accept: application/json" || echo 000)
          if [[ "$CODE" -lt 200 || "$CODE" -ge 300 ]]; then
            echo "‚ùå Failed to fetch lifecycles list for project '$PROJECT_KEY' (HTTP $CODE)" >&2
            cat "$LC_FILE" || true
            rm -f "$LC_FILE"
            exit 1
          fi
          NORM_FILE=$(mktemp)
          jq -c 'if type=="array" then . elif has("lifecycles") then .lifecycles elif has("items") then .items elif has("results") then .results elif (has("name") and has("stages")) then [.] else [] end' "$LC_FILE" > "$NORM_FILE" 2>/dev/null || printf '[]' > "$NORM_FILE"
          rm -f "$LC_FILE"
          LIFECYCLE_NAME="${LIFECYCLE_NAME:-bookverse-lifecycle}"
          NAMES=$(jq -r --arg n "$LIFECYCLE_NAME" 'map(select(.name == $n)) | .[0].stages // [] | map(if type=="object" then .name else . end) | .[]' "$NORM_FILE" 2>/dev/null || true)
          RELEASE_STAGE=$(jq -r --arg n "$LIFECYCLE_NAME" '([ .[] | select(.name == $n) | .releaseStage ] | .[0]) // empty' "$NORM_FILE" 2>/dev/null || true)
          STAGES=(); while IFS= read -r orig; do [[ -z "$orig" ]] && continue; display=$(display_stage_for "$orig"); STAGES+=("$display"); done < <(printf "%s\n" "$NAMES")
          rm -f "$NORM_FILE"
          if [[ -n "$RELEASE_STAGE" ]]; then FINAL_STAGE=$(display_stage_for "$RELEASE_STAGE"); else FINAL_STAGE="${STAGES[$((${#STAGES[@]}-1))]}"; fi
          echo "FINAL_STAGE=$FINAL_STAGE" >> $GITHUB_ENV
          STAGES_STR="${STAGES[*]}"; echo "STAGES_STR=$STAGES_STR" >> $GITHUB_ENV
          TARGET_NAME='${{ steps.app.outputs.target_stage }}'
          echo "TARGET_NAME=$TARGET_NAME" >> $GITHUB_ENV
          echo "PROMOTED_STAGES=" >> $GITHUB_ENV
          echo "DID_RELEASE=false" >> $GITHUB_ENV
          for s in ${STAGES_STR}; do
            if [[ "$s" != "PROD" ]]; then
              api=$(api_stage_for "$s")
              echo "STAGE_${s}_ORIG=$api" >> $GITHUB_ENV
            fi
          done
          echo "‚ÑπÔ∏è Lifecycle stages: $STAGES_STR"
          echo "‚ÑπÔ∏è Target: $TARGET_NAME; Final: $FINAL_STAGE"

      - name: "[Promote] UNASSIGNED ‚Üí next"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          export JFROG_URL='${{ vars.JFROG_URL }}'
          export PROJECT_KEY='${{ vars.PROJECT_KEY }}'
          export JF_OIDC_TOKEN="$JF_OIDC_TOKEN"
          source bookverse-infra/libraries/bookverse-devops/scripts/promote-lib.sh
          fetch_summary
          ALLOW_RELEASE=false
          advance_one_step

      - name: "[Promote] Iterate to target (no release)"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          export JFROG_URL='${{ vars.JFROG_URL }}'
          export PROJECT_KEY='${{ vars.PROJECT_KEY }}'
          export JF_OIDC_TOKEN="$JF_OIDC_TOKEN"
          source bookverse-infra/libraries/bookverse-devops/scripts/promote-lib.sh
          for i in 1 2 3 4; do
            fetch_summary
            PREV=$(display_stage_for "${CURRENT_STAGE:-UNASSIGNED}")
            echo "‚û°Ô∏è Iteration $i begin: stage=$PREV target=$TARGET_NAME final=$FINAL_STAGE stages=[$STAGES_STR]"
            if [[ "$PREV" == "$TARGET_NAME" ]]; then
              echo "Reached target stage ($TARGET_NAME); stopping."
              break
            fi
            ALLOW_RELEASE=false
            advance_one_step
            fetch_summary
            CURR=$(display_stage_for "${CURRENT_STAGE:-UNASSIGNED}")
            echo "‚û°Ô∏è Iteration $i result: $PREV -> $CURR"
            if [[ "$CURR" == "$PREV" ]]; then
              echo "No further non-release promotions possible; stopping."
              break
            fi
          done

      - name: "[Evidence] Decide STAGING"
        id: decide-staging
        run: |
          set -euo pipefail
          PS="${PROMOTED_STAGES:-}"; CS="${CURRENT_STAGE:-}"; attach="false"
          if echo " $PS " | grep -q " STAGING "; then attach="true"; fi
          if [[ "$CS" == *"-STAGING" || "$CS" == "STAGING" ]]; then attach="true"; fi
          echo "attach=$attach" >> $GITHUB_OUTPUT

      - name: "[Evidence] Prepare STAGING templates"
        if: ${{ steps.decide-staging.outputs.attach == 'true' }}
        run: |
          set -euo pipefail
          cat > iac-evidence.template.md <<'EOF'

          **Scan Tool:** Snyk IaC  
          **Scan Date:** ${NOW_TS}  
          **Repository:** ${{ github.repository }}  
          **Commit:** ${{ github.sha }}

          - Critical: 0
          - High: 1
          - Medium: 2
          - Low: 3

          > Infrastructure-as-Code configuration findings for STAGING gate.
          EOF
          cat > pentest-evidence.template.md <<'EOF'

          **Engagement ID:** ${ENG_ID}  
          **Completed:** ${NOW_TS}

          - Total: 1
          - Critical: 0
          - High: 0
          - Medium: 1
          - Low: 0

          > External penetration test summary attached for STAGING gate.
          EOF
          cat > change-approval.template.md <<'EOF'

          **Change ID:** ${CHG_ID}  
          **Status:** Approved  
          **Approved By:** ${APPROVER}  
          **Approved At:** ${NOW_TS}

          > Managerial approval for release promotion from STAGING to PROD.
          EOF

      - name: "[Evidence] Attach STAGING"
        if: ${{ steps.decide-staging.outputs.attach == 'true' }}
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          if ! command -v envsubst >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y gettext-base; fi
          export NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          export ENG_ID="ENG-$(( (${GITHUB_RUN_NUMBER:-0} + ${GITHUB_RUN_ATTEMPT:-0}) % 9000 + 1000 ))"
          export CHG_ID="CHG-$(( (${GITHUB_RUN_NUMBER:-0} * 10 + ${GITHUB_RUN_ATTEMPT:-0}) ))"
          export APPROVER="user-${GITHUB_ACTOR}-${GITHUB_RUN_ATTEMPT:-1}"

          cat > iac-evidence.json <<JSON
          {"iacScan": {"tool": "Snyk", "scanDate": "${NOW_TS}", "summary": { "critical": 0, "high": 1, "medium": 2, "low": 3 }, "repository": "${{ github.repository }}", "commit": "${{ github.sha }}"}}
          JSON
          envsubst < iac-evidence.template.md > iac-evidence.md
          if jf evd create-evidence --predicate iac-evidence.json --markdown iac-evidence.md --predicate-type "https://snyk.io/evidence/iac/v1" --application-key "$APPLICATION_KEY" --application-version "$APP_VERSION" --project "${{ vars.PROJECT_KEY }}" --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" --key-alias "${{ inputs.evidence_key_alias || vars.EVIDENCE_KEY_ALIAS }}"; then
            IAC_EVIDENCE_STATUS=SUCCESS
          else
            IAC_EVIDENCE_STATUS=FAILED
          fi
          echo "IAC_EVIDENCE_STATUS=$IAC_EVIDENCE_STATUS" >> $GITHUB_ENV

          cat > pentest-evidence.json <<JSON
          {"pentest": {"provider": "Cobalt.io", "engagementId": "${ENG_ID}", "completedAt": "${NOW_TS}", "summary": { "totalFindings": 1, "critical": 0, "high": 0, "medium": 1, "low": 0 }}}
          JSON
          envsubst < pentest-evidence.template.md > pentest-evidence.md
          if jf evd create-evidence --predicate pentest-evidence.json --markdown pentest-evidence.md --predicate-type "https://cobalt.io/evidence/pentest/v1" --application-key "$APPLICATION_KEY" --application-version "$APP_VERSION" --project "${{ vars.PROJECT_KEY }}" --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" --key-alias "${{ inputs.evidence_key_alias || vars.EVIDENCE_KEY_ALIAS }}"; then
            PENTEST_EVIDENCE_STATUS=SUCCESS
          else
            PENTEST_EVIDENCE_STATUS=FAILED
          fi
          echo "PENTEST_EVIDENCE_STATUS=$PENTEST_EVIDENCE_STATUS" >> $GITHUB_ENV

          cat > change-approval.json <<JSON
          {"changeRequest": {"id": "${CHG_ID}", "status": "approved", "approvedBy": "${APPROVER}", "approvedAt": "${NOW_TS}", "environment": "STAGING"}}
          JSON
          envsubst < change-approval.template.md > change-approval.md
          if jf evd create-evidence --predicate change-approval.json --markdown change-approval.md --predicate-type "https://servicenow.com/evidence/change-req/v1" --application-key "$APPLICATION_KEY" --application-version "$APP_VERSION" --project "${{ vars.PROJECT_KEY }}" --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" --key-alias "${{ inputs.evidence_key_alias || vars.EVIDENCE_KEY_ALIAS }}"; then
            CHANGEAPPROVAL_EVIDENCE_STATUS=SUCCESS
          else
            CHANGEAPPROVAL_EVIDENCE_STATUS=FAILED
          fi
          echo "CHANGEAPPROVAL_EVIDENCE_STATUS=$CHANGEAPPROVAL_EVIDENCE_STATUS" >> $GITHUB_ENV

      - name: "[Setup] Ensure release repos exist"
        run: |
          set -euo pipefail
          JF_URL='${{ vars.JFROG_URL }}'
          TOKEN="$JF_OIDC_TOKEN"
          PROJECT='${{ vars.PROJECT_KEY }}'
          SERVICE_NAME='${{ steps.app.outputs.service_name }}'
          DOCKER_REPO="${PROJECT}-${SERVICE_NAME}-internal-docker-release-local"
          GENERIC_REPO="${PROJECT}-${SERVICE_NAME}-internal-generic-release-local"
          echo "Ensuring repos exist: $DOCKER_REPO, $GENERIC_REPO"
          repo_exists() {
            local repo_key="$1"
            curl -sS -H "Authorization: Bearer ${TOKEN}" -H "Accept: application/json" "$JF_URL/artifactory/api/repositories" | jq -e --arg k "$repo_key" '.[] | select(.key == $k) | .key' >/dev/null 2>&1
          }
          create_repo() {
            local repo_key="$1"; local pkg="$2"
            local body
            if [[ "$pkg" == "docker" ]]; then
              body='{"rclass":"local","packageType":"docker","dockerApiVersion":"V2","environments":["PROD"],"blackedOut":false,"xrayIndex":false}'
            else
              body='{"rclass":"local","packageType":"generic","environments":["PROD"],"blackedOut":false,"xrayIndex":false}'
            fi
            echo "Creating $repo_key (packageType=$pkg)"
            curl -sS -L -X PUT "$JF_URL/artifactory/api/repositories/$repo_key" -H "Authorization: Bearer ${TOKEN}" -H "Content-Type: application/json" -d "$body" | cat
          }
          patch_envs() {
            local repo_key="$1"
            echo "Patching $repo_key environments via v2 API"
            local resp
            resp=$(curl -sS -L -w '\n%{http_code}' -X PATCH "$JF_URL/artifactory/api/v2/repositories/$repo_key" -H "Authorization: Bearer ${TOKEN}" -H "Content-Type: application/json" -d '{"environments":["PROD"],"blackedOut":false}')
            local body="${resp%$'\n'*}"; local code="${resp##*$'\n'}"
            echo "$body" | cat
            echo "HTTP $code"
            if [[ "$code" -ge 200 && "$code" -lt 300 ]]; then return 0; fi
            echo "v2 PATCH failed (HTTP $code). Falling back to v1 POST update"
            local cfg="$(mktemp)"; local upd
            local get_code
            get_code=$(curl -sS -L -o "$cfg" -w "%{http_code}" -H "Authorization: Bearer ${TOKEN}" -H "Accept: application/json" "$JF_URL/artifactory/api/repositories/$repo_key" || echo 000)
            if [[ "$get_code" -ge 200 && "$get_code" -lt 300 ]]; then
              upd=$(jq -c '.environments = ["PROD"] | .blackedOut = false' "$cfg")
            else
              echo "WARN: failed to fetch current config for $repo_key (HTTP $get_code). Posting minimal config."
              if [[ "$repo_key" == *"-docker-"* ]]; then
                upd='{"rclass":"local","packageType":"docker","dockerApiVersion":"V2","environments":["PROD"],"blackedOut":false}'
              else
                upd='{"rclass":"local","packageType":"generic","environments":["PROD"],"blackedOut":false}'
              fi
            fi
            rm -f "$cfg"
            curl -sS -L -X POST "$JF_URL/artifactory/api/repositories/$repo_key" -H "Authorization: Bearer ${TOKEN}" -H "Content-Type: application/json" -d "$upd" | cat
          }
          ensure_repo_and_envs() {
            local repo_key="$1"; local pkg="$2"
            if repo_exists "$repo_key"; then
              echo "$repo_key exists"
            else
              create_repo "$repo_key" "$pkg"
            fi
            patch_envs "$repo_key" || true
          }
          ensure_repo_and_envs "$GENERIC_REPO" generic
          ensure_repo_and_envs "$DOCKER_REPO" docker

      - name: "[Release] PROD"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          export JFROG_URL='${{ vars.JFROG_URL }}'; export PROJECT_KEY='${{ vars.PROJECT_KEY }}'; source bookverse-infra/libraries/bookverse-devops/scripts/promote-lib.sh
          fetch_summary
          svc_name='${{ steps.app.outputs.service_name }}'
          docker_repo="${{ vars.PROJECT_KEY }}-${svc_name}-internal-docker-release-local"
          generic_repo="${{ vars.PROJECT_KEY }}-${svc_name}-internal-generic-release-local"
          export RELEASE_INCLUDED_REPO_KEYS=$(printf '["%s","%s"]' "$docker_repo" "$generic_repo")
          if [[ "$(display_stage_for "${CURRENT_STAGE:-}")" == "STAGING" ]]; then
            ALLOW_RELEASE=true
            set +e
            advance_one_step
            RC=$?
            set -e
            fetch_summary
            REL_STATUS="${RELEASE_STATUS:-UNKNOWN}"
            STATUS="FAILED"
            case "$REL_STATUS" in
              RELEASED|TRUSTED_RELEASE|released|trusted_release) STATUS="SUCCESS" ;;
            esac
            if [[ "$RC" -ne 0 ]]; then STATUS="FAILED"; fi
            echo "PROMO_RELEASE_ACTUAL=${REL_STATUS}" >> $GITHUB_ENV
            echo "PROMO_RELEASE_STATUS=$STATUS" >> $GITHUB_ENV
            echo "üéØ PROD Release: actual status ${REL_STATUS} ‚Äî ${STATUS}"
          else
            echo "Skipping release: current stage is $(display_stage_for "${CURRENT_STAGE:-UNASSIGNED}")"
            echo "PROMO_RELEASE_STATUS=SKIPPED" >> $GITHUB_ENV
          fi

      - name: "[Tags] Self-Healing Tag Management"
        run: |
          set -euo pipefail
          echo "üè• Running self-healing tag management for promotion"
          
          if [[ "${PROMO_RELEASE_STATUS:-}" != "SUCCESS" ]]; then
            echo "‚ÑπÔ∏è Skipping tag management; release not successful (status: ${PROMO_RELEASE_STATUS:-UNKNOWN})"
            exit 0
          fi
          
          echo "‚úÖ PROD release successful, running comprehensive tag validation and healing"
          
          export JFROG_URL='${{ vars.JFROG_URL }}'
          export PROJECT_KEY='${{ vars.PROJECT_KEY }}'
          export APPLICATION_KEY='${{ steps.app.outputs.application_key }}'
          export JF_OIDC_TOKEN="$JF_OIDC_TOKEN"
          
          source bookverse-infra/libraries/bookverse-devops/scripts/tag-management-lib.sh
          
          validate_and_heal_tags
          
          echo ""
          echo "üéØ Tag management completed for version ${{ steps.app.outputs.app_version }}"
          echo "üìã All versions now have correct tags based on their states:"
          echo "   - 'latest': Highest SemVer version in PROD"
          echo "   - 'quarantine': Versions that were rolled back"
          echo "   - 'valid': Other valid SemVer versions"
          echo "   - Non-SemVer versions: No special tags (ignored for 'latest')"

      - name: "[Summary] Promotion"
        if: always()
        run: |
          set -euo pipefail
          CURRENT_DISPLAY="${CURRENT_STAGE_BEFORE:-UNASSIGNED}"
          TARGET_DISPLAY="${TARGET_NAME:-${FINAL_STAGE:-UNKNOWN}}"
          export CURRENT_DISPLAY TARGET_DISPLAY
          STAGES="${STAGES_STR:-DEV QA STAGING PROD}"
          IFS=' ' read -r -a STAGE_ARR <<< "$STAGES"
          idx_current=-1; idx_target=-1
          for i in "${!STAGE_ARR[@]}"; do
            if [[ "${STAGE_ARR[$i]}" == "$CURRENT_DISPLAY" ]]; then idx_current=$i; fi
            if [[ "${STAGE_ARR[$i]}" == "$TARGET_DISPLAY" ]]; then idx_target=$i; fi
          done
          pre=""; post=""; sep=""
          if [[ $idx_current -ge 0 && $idx_target -ge 0 ]]; then
            for ((j=0;j<idx_current;j++)); do
              if [[ -n "$pre" ]]; then sep=" ‚Üí "; else sep=""; fi
              pre+="$sep${STAGE_ARR[$j]}"
            done
            for ((j=idx_target+1;j<${#STAGE_ARR[@]};j++)); do
              if [[ -n "$post" ]]; then sep=" ‚Üí "; else sep=""; fi
              post+="$sep${STAGE_ARR[$j]}"
            done
            LC_PATH="${pre:+$pre ‚Üí }**${CURRENT_DISPLAY} ‚ûî ${TARGET_DISPLAY}**${post:+ ‚Üí $post}"
          else
            LC_PATH="$STAGES"
          fi
          OUTCOME="SUCCESS"
          for s in "${PROMO_UNASSIGNED_STATUS:-}" "${PROMO_DEV_STATUS:-}" "${PROMO_QA_STATUS:-}" "${PROMO_STAGING_STATUS:-}" "${PROMO_RELEASE_STATUS:-}"; do
            if [[ "$s" == "FAILED" ]]; then OUTCOME="FAILURE"; fi
          done
          if [[ "$OUTCOME" == "SUCCESS" ]]; then
            for s in "${IAC_EVIDENCE_STATUS:-}" "${PENTEST_EVIDENCE_STATUS:-}" "${CHANGEAPPROVAL_EVIDENCE_STATUS:-}"; do
              if [[ "$s" == "FAILED" ]]; then OUTCOME="WARNING"; fi
            done
          fi
          PROMOTION_METHOD="move"
          node - <<'NODE' | tee -a "$GITHUB_STEP_SUMMARY" >/dev/null
          (function(){
            function iconFor(status){
              switch ((status||'').toUpperCase()) {
                case 'SUCCESS': return '‚úÖ';
                case 'WARNING': return '‚ö†Ô∏è';
                case 'FAILURE': return '‚ùå';
                case 'FAILED': return '‚ùå';
                default: return '‚Äì';
              }
            }
            const env = process.env;
            const app = env.APPLICATION_KEY || '';
            const ver = env.APP_VERSION || '';
            const current = env.CURRENT_DISPLAY || '';
            const target = env.TARGET_DISPLAY || '';
            const lifecycleDefined = `UNASSIGNED ‚Üí ${(env.STAGES_STR || 'DEV QA STAGING PROD').split(' ').join(' ‚Üí ')}`;
            const promoMethod = (env.PROMOTION_METHOD || 'move');
            const sUnassigned = (env.PROMO_UNASSIGNED_STATUS || '').toUpperCase();
            const sDev = (env.PROMO_DEV_STATUS || '').toUpperCase();
            const sQa = (env.PROMO_QA_STATUS || '').toUpperCase();
            const sStg = (env.PROMO_STAGING_STATUS || '').toUpperCase();
            const sRel = (env.PROMO_RELEASE_STATUS || '').toUpperCase();
            const evIac = (env.IAC_EVIDENCE_STATUS || '').toUpperCase();
            const evPentest = (env.PENTEST_EVIDENCE_STATUS || '').toUpperCase();
            const evChange = (env.CHANGEAPPROVAL_EVIDENCE_STATUS || '').toUpperCase();
            function stepOutcomeFromPlatform(stepStatus){
              const st = (stepStatus||'').toUpperCase();
              if (st === 'FAILED' || st === 'FAILURE') return 'FAILURE';
              if (!st) return 'SKIPPED';
              return 'SUCCESS';
            }
            function evidenceLine(name, status, hint){
              const up = (status||'').toUpperCase();
              if (up === 'FAILED') return `  - ‚ùå ${name} (failed)`;
              if (up === 'SUCCESS') return `  - ‚úÖ ${name}`;
              return `  - ${name} (${hint || 'not evaluated'})`;
            }
            function stepSection(from, to, kind, constraints, evidences, stepStatus){
              const promoResult = stepOutcomeFromPlatform(stepStatus);
              const hasEvidenceFail = evidences.some(e => (e.status||'').toUpperCase() === 'FAILED');
              const stepOutcome = promoResult === 'FAILURE' ? 'FAILURE' : (hasEvidenceFail ? 'WARNING' : 'SUCCESS');
              const lines = [];
              lines.push(`
              lines.push(`- **Type:** ${kind}`);
              lines.push(`- **Constraints:** ${constraints || 'None'}`);
              lines.push(`- **Evidence Used:**`);
              if (!evidences.length) { lines.push(`  - (none)`); } else { evidences.forEach(e => lines.push(evidenceLine(e.name, e.status, e.hint))); }
              lines.push(`- **Promotion Result:** ${iconFor(promoResult)} ${promoResult}`);
              lines.push(`- **Step Outcome:** ${iconFor(stepOutcome)} ${stepOutcome}`);
              return { text: lines.join('\n'), outcome: stepOutcome };
            }
            const sec1 = stepSection('UNASSIGNED','DEV',`Promote (${promoMethod})`, 'None', [
              { name: 'SLSA Provenance (UNASSIGNED)', status: '', hint: 'attached in CI; not evaluated here' },
              { name: 'Jira Release Notes (UNASSIGNED)', status: '', hint: 'attached in CI; not evaluated here' },
            ], sUnassigned);
            const sec2 = stepSection('DEV','QA',`Promote (${promoMethod})`, 'None', [
              { name: 'Coverage (pytest) [Package]', status: '', hint: 'attached in CI; not evaluated here' },
              { name: 'SAST (Checkmarx) [Package]', status: '', hint: 'attached in CI; not evaluated here' },
            ], sDev);
            const sec3 = stepSection('QA','STAGING',`Promote (${promoMethod})`, 'None', [
              { name: 'DAST (Invicti)', status: '', hint: 'not configured in this workflow' },
              { name: 'API Tests (Postman)', status: '', hint: 'not configured in this workflow' },
            ], sQa);
            const sec4 = stepSection('STAGING','PROD',`Release (${promoMethod})`, 'None', [
              { name: 'Snyk IaC', status: evIac },
              { name: 'Cobalt Pentest', status: evPentest },
              { name: 'ServiceNow Change Approval', status: evChange },
            ], sRel);
            const outcomes = [sec1.outcome, sec2.outcome, sec3.outcome, sec4.outcome].filter(Boolean);
            let overall = 'SUCCESS';
            if (outcomes.some(o => o === 'FAILURE')) overall = 'FAILURE';
            else if (outcomes.some(o => o === 'WARNING')) overall = 'WARNING';
            const exec = [
              `
              `- **Lifecycle:** ${lifecycleDefined}`,
              `- **Application:** ${app}`,
              `- **Version:** ${ver}`,
              `- **From ‚Üí To:** ${current} ‚Üí ${target}`,
              `- **Outcome:** ${iconFor(overall)} ${overall}`,
            ].join('\n');
            const report = [exec, '', sec1.text, '', sec2.text, '', sec3.text, '', sec4.text].join('\n');
            process.stdout.write(report);
          })();
          NODE


